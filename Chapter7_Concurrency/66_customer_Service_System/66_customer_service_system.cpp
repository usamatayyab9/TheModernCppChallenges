/**
 * @file 66_customer_service_system.cpp
 * @author Usama Tayyab (usamatayyab9@gmail.com)
 * @brief 
 * Compilation command : g++ -std=c++17 66_customer_service_system.cpp -lpthread
 * 
 * This file is solution to "Problem 66. Customer service system"
 *  mentioned in "Chapter 7: Concurrency" of the book:
 *  - The Modern C++ Challenge by Marius Bancilla (available at amazon https://www.amazon.com/Modern-Challenge-programmer-real-world-problems/dp/1788993861)
 * 
 * Solution:
 * 
 * - The thread-safe class `TicketingMachine` is used to generate ticket number for customers.
 * - The thread-safe class `Customer` which provides detailes related to a customer. Each
 *   customer must be initialzed with a ticket number. More information about customer 
 *   can be added to this class. Also provides an overload or operator < for customers
 *   to be ordered.
 * - The thread-safe class `CustomerQueue` which provides an ordering queue for customer
 *   and functions to fetch customers from the queue. A customer with smaller ticket
 *   number will be removed frist from the queue than the customer with greater ticket number.
 * - A funcition `DesksThread` which is processes customer queue. 
 *  
 * 
 * Driver code:
 * - Initializes a thread-safe logger for logging all the activities
 * - Intializes a thread-safe customer queue which deskt thread uses to extract
 *      customers from.
 * - Initializes an atomic boolean flag which indicates whether office is open or not.
 * - Launches three desk threads and then sleep for 2s. Sleep is added so that desk
 *      threads are launched and have started executing.
 * - Create 25 new customers at random intervals. Each newly created customer is assigned
 *  a ticket number at its construction, this ticket number is used to order customers.
 *  Ticket number is generated by thread-safe class `TicketingMachine`. All customers are
 *  ordered in a queue provided by class `CustomerQueue`.
 * - Once all customers are created and inserted into the queue, sets the `office_open` flag
 *  to false and waits for desks to finish execution.
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include <iostream>
#include <mutex>
#include <chrono>
#include <thread>
#include <vector>
#include <string>
#include <string_view>
#include <queue>
#include <atomic>
#include <optional>
#include <random>

#include "thread_safe_logger.h"

using std::array;
using std::atomic_bool;
using std::chrono::milliseconds;
using std::cout;
using std::lock_guard;
using std::mt19937;
using std::mutex;
using std::optional;
using std::priority_queue;
using std::random_device;
using std::string;
using std::thread;
using std::to_string;
using std::uniform_int_distribution;
using std::vector;
using namespace std::this_thread;
using namespace std::chrono_literals;

/**
 * @brief A simple ticketing machine class.
 *
 * This class provides a mechanism to get unique ticket numbers in a thread-safe manner.
 */
class TicketingMachine
{
public:
    /**
    * @brief Gets the next available ticket number.
    *
    * @return The next available ticket number.
    */
    static int GetTicketNumber()
    {
        auto lock          = lock_guard{ mutex_ };
        const auto kTicket = ticket_;
        ++ticket_;
        return kTicket;
    }
private:
    inline static int ticket_ = 0; /** The current ticket number. */
    static mutex mutex_; /**Mutex to ensure thread safety when getting ticket numbers. */
};
mutex TicketingMachine::mutex_;

/**
 * @brief Represents a customer with a ticket number.
 */
class Customer
{
public:
    Customer() = delete;
    /**
    * @brief Constructs a customer with a specified ticket number.
    *
    * @param ticket The ticket number assigned to the customer.
    */
    Customer(const int &ticket) : ticket_no_{ ticket }
    {

    }
    int GetTicket() const 
    {
        return ticket_no_;
    }
    bool operator<(const Customer &rhs) const
    {
        return this->ticket_no_ < rhs.ticket_no_;
    }
private:
    int ticket_no_;
};

/**
* @brief Represents a queue of customers with ordering based on their ticket numbers.
*/
class CustomerQueue
{
public:
    void InsertCustomer(Customer customer)
    {
        auto guard = lock_guard{ mutex_ };
        customer_ordering_.push(customer);
    }

    /**
     * @brief Retrieves and removes the next customer from the queue.
     *
     * @return An optional containing the next customer if the queue is not empty; otherwise, an empty optional.
     */
    optional<Customer> GetNextCustomer()
    {
        auto return_data = optional<Customer>{};
        
        if (auto guard = lock_guard{ mutex_ }; false == customer_ordering_.empty())
        {
            return_data = customer_ordering_.top();
            customer_ordering_.pop();
        }
        return return_data;
    }

    bool empty()
    {
        auto guard          = lock_guard{ mutex_ };
        const auto kIsEmpty = customer_ordering_.empty();
        return kIsEmpty;
    }

    size_t size()
    {
        auto guard     = lock_guard{ mutex_ };
        const auto kSz = customer_ordering_.size();
        return kSz;
    }
private:
    mutex                    mutex_;
    priority_queue<Customer> customer_ordering_;
};

/**
 * @brief Represents a thread function for handling customer desks.
 * Keeps executing until the office is open or there are some
 * customers left to be processed.
 * @param desk_idx       - The index of the desk.
 * @param is_office_open - An atomic boolean indicating whether the office is open.
 * @param customer_list  - The thread-safe customer queue for the desks.
 * @param logger         - The thread-safe logger for logging desk activities.
*/
void DesksThread(const int desk_idx, atomic_bool &is_office_open,
                CustomerQueue &customer_list, Logger_mt &logger)
{
    auto rd      = random_device{};
    auto gen     = mt19937 (rd());
    auto distrib = uniform_int_distribution<>(2000, 3000);

    logger.Log("Desk " + to_string(desk_idx) + " starting");
    while (is_office_open || (customer_list.size() > 0))
    {
        if (auto customer = customer_list.GetNextCustomer(); customer)
        {
            logger.Log(string{ "Desk " }.append(to_string(desk_idx))
                .append(" handling Customer ").append(to_string(customer.value().GetTicket()))
            
            );
            sleep_for(1s);
            logger.Log(string{ "Desk " }.append(to_string(desk_idx))
                .append(" done with Customer ").append(to_string(customer.value().GetTicket()))
            
            );
        }
        sleep_for(milliseconds{ distrib(gen) });
    }
    logger.Log("Desk " + to_string(desk_idx) + " Closing");
}

int main()
{
    auto console_mt_logger  = Logger_mt{ cout };
    auto customer_queue     = CustomerQueue{};
    auto is_office_open     = atomic_bool{ true };

    constexpr auto kTotalDesks = 3;
    auto desks = array<thread, kTotalDesks>{};
    for (auto idx = size_t{ 0 }; idx < size(desks) ;++idx)
    {
        desks[idx] = thread{ DesksThread, idx + 1, std::ref(is_office_open), std::ref(customer_queue), std::ref(console_mt_logger) };
    }


    sleep_for(2s);
    auto rd      = random_device{};
    auto gen     = mt19937 (rd());
    auto distrib = uniform_int_distribution<>(2000, 3000);
    for (auto i = 0; i < 25 ;++i)
    {
        sleep_for(milliseconds{ distrib(gen) });
        auto C = Customer{ TicketingMachine::GetTicketNumber() };
        customer_queue.InsertCustomer(C);
        console_mt_logger.Log("New Customer ");
        
    }

    is_office_open = false;
    for (auto &desk : desks) { desk.join(); }

    return 0;
}